# MFC — Run Tesseract CLI, capture stdout and show text in a dialog

> Ready-to-drop example you can copy into a `.md` file. Dialog-based MFC app that runs the `tesseract` CLI, captures its stdout (UTF‑8), and shows the OCR text in a multi-line edit control.

---

## Overview

This guide shows a compact, working approach using `std::thread` + `_popen()` to run the Tesseract command-line executable, read its output (UTF‑8), convert it to `wchar_t`, and post the result back to the main UI thread.

We use a dialog with:
- an edit control to enter the input image/file path (`IDC_EDIT_INPUT`)
- a button to start OCR (`IDC_BUTTON_RUN`)
- a multi-line read-only edit control to show results (`IDC_EDIT_OUTPUT`)

This approach keeps the UI responsive and is simple to drop into a Visual Studio MFC Dialog-based project.

---

## Prerequisites

- Visual Studio (with MFC support)
- Tesseract CLI installed on the machine and reachable from PATH (or provide full path to `tesseract.exe` in the UI)
- Basic familiarity with creating a Dialog-based MFC project

> **Note:** Tesseract outputs UTF‑8. This example converts UTF‑8 to `wchar_t` before updating the MFC control.

---

## Quick project setup (step-by-step)

1. Create a new **MFC App** in Visual Studio. Choose **Dialog based**.
2. Replace the default dialog resource controls/IDs (or add new ones). See the `resource.h` / `.rc` snippets below.
3. Add a dialog class (e.g. `CMyDialog`) or edit the one generated by the wizard.
4. Add the `.h` and `.cpp` code below to the dialog class and wire the button click.
5. Build and run. Enter an image path (or full path to `tesseract.exe`) and click **Run Tesseract**.

---

## Resource definitions

**resource.h** (add these IDs)

```cpp
// resource.h
#define IDD_MAINDLG      101
#define IDC_EDIT_INPUT   1001
#define IDC_BUTTON_RUN   1002
#define IDC_EDIT_OUTPUT  1003
```

**Minimal .rc dialog** (replace your dialog's contents with something like this)

```
IDD_MAINDLG DIALOGEX 0, 0, 320, 200
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
FONT 8, "MS Shell Dlg"
BEGIN
    LTEXT           "Input image path:", -1, 10, 10, 80, 10
    EDITTEXT        IDC_EDIT_INPUT, 10, 22, 300, 16, ES_AUTOHSCROLL
    PUSHBUTTON      "Run Tesseract", IDC_BUTTON_RUN, 10, 44, 110, 18
    CONTROL         "", IDC_EDIT_OUTPUT, "Edit", ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY | WS_BORDER | WS_TABSTOP, 10, 70, 300, 110
END
```

(Adjust the dialog ID, sizes and style to match your project.)

---

## Dialog header (CMyDialog.h)

```cpp
#pragma once

#include <afxwin.h>
#include <string>
#include <thread>

// custom message used to transfer OCR text pointer from worker thread to main dialog
#define WM_OCR_OUTPUT (WM_APP + 1)

class CMyDialog : public CDialogEx
{
public:
    CMyDialog(CWnd* pParent = nullptr);
    enum { IDD = IDD_MAINDLG };

protected:
    virtual BOOL OnInitDialog() override;

    afx_msg void OnBnClickedButtonRun();
    afx_msg LRESULT OnOcrOutputReady(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()

private:
    CEdit m_editInput;
    CEdit m_editOutput;

    // no joining - we detach threads for this simple example
};
```

---

## Dialog implementation (CMyDialog.cpp)

> If your project uses precompiled headers, include `pch.h` (or `stdafx.h`) first.

```cpp
#include "pch.h" // or stdafx.h if your project uses that
#include "CMyDialog.h"
#include "resource.h"
#include <windows.h>
#include <stdio.h>    // _popen, _pclose

BEGIN_MESSAGE_MAP(CMyDialog, CDialogEx)
    ON_BN_CLICKED(IDC_BUTTON_RUN, &CMyDialog::OnBnClickedButtonRun)
    ON_MESSAGE(WM_OCR_OUTPUT, &CMyDialog::OnOcrOutputReady)
END_MESSAGE_MAP()

CMyDialog::CMyDialog(CWnd* pParent)
    : CDialogEx(IDD, pParent)
{
}

BOOL CMyDialog::OnInitDialog()
{
    CDialogEx::OnInitDialog();

    // subclass controls
    m_editInput.SubclassDlgItem(IDC_EDIT_INPUT, this);
    m_editOutput.SubclassDlgItem(IDC_EDIT_OUTPUT, this);

    // make output control read-only & multi-line already from resource styles
    return TRUE;
}

// helpers
static std::string WideToUtf8(const std::wstring& w)
{
    if (w.empty()) return {};
    int size_needed = WideCharToMultiByte(CP_UTF8, 0, w.c_str(), -1, NULL, 0, NULL, NULL);
    std::string s;
    if (size_needed > 1) {
        s.resize(size_needed - 1);
        WideCharToMultiByte(CP_UTF8, 0, w.c_str(), -1, &s[0], size_needed, NULL, NULL);
    }
    return s;
}

static std::wstring Utf8ToWide(const std::string& s)
{
    if (s.empty()) return {};
    int size_needed = MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, NULL, 0);
    std::wstring w;
    if (size_needed > 1) {
        w.resize(size_needed - 1);
        MultiByteToWideChar(CP_UTF8, 0, s.c_str(), -1, &w[0], size_needed);
    }
    return w;
}

void CMyDialog::OnBnClickedButtonRun()
{
    CString wInput;
    m_editInput.GetWindowText(wInput);
    std::wstring wsInput = std::wstring(wInput);

    if (wsInput.empty()) {
        AfxMessageBox(L"Enter an input image path (or full path to tesseract.exe + args).\nExample: C:\\images\\page1.png");
        return;
    }

    // Build a command-line for tesseract. We assume tesseract is on PATH.
    // If you installed tesseract in a non-PATH location, put full path in the input or change below.
    std::string inputUtf8 = WideToUtf8(wsInput);

    // Example: tesseract "C:\path\image.png" stdout -l eng 2>&1
    std::string cmd = "tesseract " + std::string("\"") + inputUtf8 + std::string("\" stdout -l eng 2>&1");

    HWND hWnd = this->GetSafeHwnd();

    // Launch worker thread so UI is not blocked
    std::thread worker([cmd, hWnd]() {
        FILE* pipe = _popen(cmd.c_str(), "rb"); // read raw bytes
        if (!pipe) {
            const char* err = "ERROR: failed to run tesseract (popen failed)";
            int wlen = MultiByteToWideChar(CP_UTF8, 0, err, -1, NULL, 0);
            wchar_t* wbuf = new wchar_t[wlen];
            MultiByteToWideChar(CP_UTF8, 0, err, -1, wbuf, wlen);
            PostMessageW(hWnd, WM_OCR_OUTPUT, (WPARAM)wbuf, 0);
            return;
        }

        std::string out;
        char buffer[4096];
        while (fgets(buffer, sizeof(buffer), pipe)) {
            out.append(buffer);
        }
        _pclose(pipe);

        // Convert UTF-8 output to wide string
        int wlen = MultiByteToWideChar(CP_UTF8, 0, out.c_str(), -1, NULL, 0);
        if (wlen <= 0) {
            const char* err = "ERROR: failed to convert output from UTF-8";
            int elen = MultiByteToWideChar(CP_UTF8, 0, err, -1, NULL, 0);
            wchar_t* ebuf = new wchar_t[elen];
            MultiByteToWideChar(CP_UTF8, 0, err, -1, ebuf, elen);
            PostMessageW(hWnd, WM_OCR_OUTPUT, (WPARAM)ebuf, 0);
            return;
        }

        wchar_t* wbuf = new wchar_t[wlen];
        MultiByteToWideChar(CP_UTF8, 0, out.c_str(), -1, wbuf, wlen);

        // post the pointer to UI thread. UI will delete[] it when done.
        PostMessageW(hWnd, WM_OCR_OUTPUT, (WPARAM)wbuf, 0);
    });

    worker.detach();
}

LRESULT CMyDialog::OnOcrOutputReady(WPARAM wParam, LPARAM /*lParam*/)
{
    wchar_t* wbuf = reinterpret_cast<wchar_t*>(wParam);
    if (wbuf) {
        m_editOutput.SetWindowTextW(wbuf);
        delete[] wbuf; // free the heap buffer allocated by worker
    }
    return 0;
}
```

---

## Notes and extensions

- **Tesseract path**: If `tesseract.exe` isn't on `PATH`, either give a full path in `cmd` or let the user enter the full Tesseract path and file path in the input control.
- **Capture stderr**: We append `2>&1` to the command so stderr is merged into stdout and also shown in the output edit control (helpful for debugging).
- **Large output**: For very long outputs you may prefer to append to the edit control rather than `SetWindowText` (use `SetSel(-1, -1)` and `ReplaceSel`).
- **PDF input**: Tesseract generally expects image files. For PDF you must pre-convert pages to images (e.g. `pdftoppm` or ImageMagick/ghostscript) then OCR each resulting image, or use Tesseract 5's PDF support but be mindful of formats.
- **Security**: Avoid building command lines with untrusted input. The example is fine for local automation but be careful if your UI accepts arbitrary input from unknown users.

---

## Troubleshooting

- If output is garbage: confirm Tesseract prints UTF‑8 and your conversion is using `CP_UTF8`.
- If `_popen` fails: ensure PATH includes tesseract or provide full path and that your process has permission to execute it.
- If the UI never updates: ensure `PostMessageW` is used and the dialog's message handler (`ON_MESSAGE`) is declared correctly.

---

## Alternatives

- Use `CreateProcess` with explicit anonymous pipes if you want more control (non-blocking pipes, overlapped I/O, separate stderr/stdout streams). The `_popen` route is much shorter and practical for many use cases.
- If you prefer using the ABBYY/FineReader engines or other SDKs (which provide native API integration), they typically offer direct API calls instead of CLI calls.

---

## License

Copy and adapt this example freely. If you want a version that uses `CreateProcess` + `ReadFile` with `OVERLAPPED` I/O or a version that logs progress per-line as Tesseract emits it, tell me and I will add it.


---

**End of document**

